import { useEffect, useMemo, useState } from "react";
import { motion } from "framer-motion";
import { Calendar, Users, Search, AlertTriangle, LayoutDashboard, Info, SlidersHorizontal } from "lucide-react";
import KPICard from "@/components/KpiCard";
import type { DateRange, Metric } from "@/types/dashboard";
import type { SimpleDatum } from "@/components/charts/ChartCards";
import {
  ChartCard,
  DistributionBarChart,
  PriorityDonutChart,
  SlaByGroupChart,
  TopAnalystsChart,
  TrendLineChart,
  VolumeByGroupChart,
} from "@/components/charts/ChartCards";
import {
  type CallBucket,
  type TicketBucket,
} from "@/data/periodDataset";
import { useRealDashboardData, type Agent, type Group } from "@/hooks/useRealDashboardData";
import { useMetrics } from "@/hooks/useMetrics";
import { useHdiMetrics } from "@/hooks/useHdiMetrics";

// Tipos para tickets raw da API
type RawTicket = {
  id: number;
  created_at: string;
  resolved_at?: string | null;
  closed_at?: string | null;
  first_responded_at?: string | null;
  due_by?: string | null;
  fr_due_by?: string | null;
  status: number;
  priority: number;
  group_id?: number | null;
  responder_id?: number | null;
  reopened_count?: number;
  custom_fields?: {
    cf_csat_rating?: number;
  };
};

type SummaryTone = "success" | "warning" | "danger" | "neutral";

interface SummaryCard {
  id: string;
  label: string;
  value: string;
  helper: string;
  status?: SummaryTone;
  badge?: string;
  row?: number;
}

interface LeaderboardEntry {
  name: string;
  sla: number;
  resolved: number;
  avgTime: string;
}

interface AnalystDetail {
  name: string;
  resolved: number;
  sla: number;
  reopened: number;
}

interface OperationalData {
  status: SimpleDatum[];
  urgency: SimpleDatum[];
  priority: SimpleDatum[];
  trend: { name: string; tickets: number }[];
  sla: SimpleDatum[];
  volume: SimpleDatum[];
  topAnalysts: SimpleDatum[];
  leaderboard: LeaderboardEntry[];
  analystsTable: AnalystDetail[];
}

interface ComputedView {
  serviceCards: SummaryCard[];
  metrics: Metric[];
  operational: OperationalData;
}

type DashboardView = "overview" | "kpis" | "equipe" | "telefonia" | "full";

const toneBadge: Record<SummaryTone, string> = {
  success: "border-emerald-100 bg-emerald-50 text-emerald-700",
  warning: "border-amber-100 bg-amber-50 text-amber-700",
  danger: "border-rose-100 bg-rose-50 text-rose-600",
  neutral: "border-slate-200 bg-white text-slate-500",
};

const statusColors: Record<string, string> = {
  resolved: "#22c55e",
  pending: "#fbbf24",
  sla_breach: "#ef4444",
};

const priorityColors: Record<string, string> = {
  Baixa: "#bfdbfe",
  Média: "#2563eb",
  Alta: "#fbbf24",
  Urgente: "#ef4444",
};

const urgencyColors: Record<string, string> = {
  Baixa: "#bae6fd",
  Média: "#60a5fa",
  Alta: "#f97316",
  Urgente: "#ef4444",
};

const toDate = (value: string) => new Date(`${value}T00:00:00`);

// Helper para formatar datas no padrão YYYY-MM-DD usado pelos inputs
const formatDateInput = (date: Date) => {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
};

const percentage = (part: number, total: number) => (total > 0 ? (part / total) * 100 : 0);

const formatLargeNumber = (value: number) => value.toLocaleString("pt-BR");

const formatPercent = (value: number, decimals = 0) =>
  `${(Number.isFinite(value) ? value : 0).toFixed(decimals)}%`;

const formatMinutesShort = (minutes: number) => {
  if (!Number.isFinite(minutes) || minutes <= 0) return "0m";
  const hrs = Math.floor(minutes / 60);
  const mins = Math.max(0, Math.round(minutes % 60));
  if (hrs === 0) return `${mins}m`;
  return `${hrs}h ${mins}m`;
};

const filterBuckets = <T extends { date: string; analyst: string }>(
  buckets: T[],
  range: DateRange,
  analyst: string,
) => {
  const start = toDate(range.start).getTime();
  const end = toDate(range.end).getTime();
  return buckets.filter(bucket => {
    const date = toDate(bucket.date).getTime();
    const withinRange = date >= start && date <= end;
    const matchAnalyst = analyst === "all" || bucket.analyst === analyst;
    return withinRange && matchAnalyst;
  });
};

interface TicketSummary {
  total: number;
  resolved: number;
  slaMet: number;
  reopened: number;
  firstResponseMet: number;
  firstResponseMinutes: number;
  resolutionMinutes: number;
  csatSum: number;
  csatCount: number;
}

const summarizeTickets = (tickets: TicketBucket[]): TicketSummary =>
  tickets.reduce<TicketSummary>(
    (acc, ticket) => {
      const { count } = ticket;
      acc.total += count;

      // Considerar resolvido qualquer bucket com tempo de resolução > 0,
      // independentemente do status mapeado.
      if (ticket.resolutionMinutes > 0) {
        acc.resolved += count;
        acc.resolutionMinutes += ticket.resolutionMinutes;
      }
      
      // HDI: Contar apenas tickets que têm SLA definido e foram resolvidos
      if (ticket.slaMet) acc.slaMet += count;
      
      // HDI: Contar apenas tickets que têm primeira resposta dentro do SLA
      if (ticket.firstResponseMet) acc.firstResponseMet += count;
      
      // HDI: Acumular apenas tempos de primeira resposta que existem
      // firstResponseMinutes no bucket já é a soma dos tempos de primeira resposta
      if (ticket.firstResponseMinutes > 0) {
        acc.firstResponseMinutes += ticket.firstResponseMinutes;
      }
      
      // reopened já está acumulado no bucket
      acc.reopened += ticket.reopened;
      
      // CSAT apenas se tiver score válido
      if (typeof ticket.csatScore === "number") {
        acc.csatSum += ticket.csatScore * count;
        acc.csatCount += count;
      }
      return acc;
    },
    {
      total: 0,
      resolved: 0,
      slaMet: 0,
      reopened: 0,
      firstResponseMet: 0,
      firstResponseMinutes: 0,
      resolutionMinutes: 0,
      csatSum: 0,
      csatCount: 0,
    },
  );

function buildServiceCardsFromRaw(
  rawTickets: RawTicket[],
  startDateStr: string,
  endDateStr: string,
): SummaryCard[] {
  // Retornar cards vazios se não há dados ainda
  if (!startDateStr || !endDateStr) {
    return [];
  }
  
  // Se não há tickets, retornar cards com valores zerados
  if (!Array.isArray(rawTickets) || rawTickets.length === 0) {
    return [
      { id: "tickets_periodo", label: "Tickets recebidos", value: "0", helper: "Clique em Buscar para carregar dados", row: 1 },
      { id: "tickets_nao_resolvidos", label: "Tickets não resolvidos", value: "0", helper: "Clique em Buscar para carregar dados", row: 1 },
      { id: "tickets_resolvidos", label: "Tickets resolvidos", value: "0", helper: "Clique em Buscar para carregar dados", row: 1 },
      { id: "fcr", label: "Taxa de resolução", value: "0%", helper: "Clique em Buscar para carregar dados", row: 1 },
      { id: "sla_resolucao", label: "SLA de resolução", value: "0%", helper: "Clique em Buscar para carregar dados", row: 2 },
      { id: "tempo_resolucao", label: "Tempo médio de resolução", value: "0m", helper: "Clique em Buscar para carregar dados", row: 2 },
      { id: "sla_primeira_resposta", label: "SLA de primeira resposta", value: "0%", helper: "Clique em Buscar para carregar dados", row: 2 },
      { id: "tempo_primeira_resposta", label: "Tempo médio 1ª resposta", value: "0m", helper: "Clique em Buscar para carregar dados", row: 2 },
    ];
  }

  const start = new Date(startDateStr + "T00:00:00");
  const end = new Date(endDateStr + "T23:59:59");

  let recebidos = 0;
  let resolvidos = 0;
  let naoResolvidosAtuais = 0;

  let slaMet = 0;
  let resolutionMinutesSum = 0;

  let firstRespMet = 0;
  let firstRespMinutesSum = 0;
  let firstRespCount = 0;

  let reopenedTickets = 0;

  let csatSum = 0;
  let csatCount = 0;

  const minutesBetween = (startIso: string | null | undefined, endIso: string | null | undefined): number => {
    if (!startIso || !endIso) return 0;
    const d1 = new Date(startIso);
    const d2 = new Date(endIso);
    return Math.max(0, Math.round((d2.getTime() - d1.getTime()) / (1000 * 60)));
  };

  rawTickets.forEach(ticket => {
    const createdAt = new Date(ticket.created_at);
    const resolvedAtIso = ticket.resolved_at || ticket.closed_at || null;
    const resolvedAt = resolvedAtIso ? new Date(resolvedAtIso) : null;

    const createdInPeriod = createdAt >= start && createdAt <= end;
    const resolvedInPeriod = resolvedAt && resolvedAt >= start && resolvedAt <= end;

    // Tickets Recebidos: criados no período
    if (createdInPeriod) {
      recebidos += 1;
    }

    // Tickets Não Resolvidos: backlog atual (sem resolved_at/closed_at)
    if (!resolvedAtIso) {
      naoResolvidosAtuais += 1;
    }

    // Tickets Resolvidos: resolvidos no período, mesmo que criados antes
    if (resolvedInPeriod && resolvedAtIso) {
      resolvidos += 1;

      // Tempo de resolução
      const resMinutes = minutesBetween(ticket.created_at, resolvedAtIso);
      if (resMinutes > 0) {
        resolutionMinutesSum += resMinutes;
      }

      // SLA de resolução
      if (ticket.due_by) {
        const due = new Date(ticket.due_by);
        if (resolvedAt <= due) {
          slaMet += 1;
        }
      }

      // Reabertura: considerar tickets com pelo menos 1 reabertura
      if ((ticket.reopened_count ?? 0) > 0) {
        reopenedTickets += 1;
      }
    }

    // SLA e tempo de 1ª resposta: considerar respostas no período
    if (ticket.first_responded_at) {
      const firstRespAt = new Date(ticket.first_responded_at);
      const respMinutes = minutesBetween(ticket.created_at, ticket.first_responded_at);
      if (respMinutes > 0) {
        firstRespMinutesSum += respMinutes;
        firstRespCount += 1;
      }

      if (firstRespAt >= start && firstRespAt <= end && ticket.fr_due_by) {
        const frDue = new Date(ticket.fr_due_by);
        if (firstRespAt <= frDue) {
          firstRespMet += 1;
        }
      }
    }

    // CSAT médio: qualquer ticket com avaliação, independente da data, mas alinhado ao período de resolvidos
    const rating =
      (ticket as any).satisfaction_rating?.rating ?? ticket.custom_fields?.cf_csat_rating;
    if (typeof rating === "number") {
      csatSum += rating;
      csatCount += 1;
    }
  });

  const slaPercent = resolvidos > 0 ? percentage(slaMet, resolvidos) : 0;
  const avgResolution = resolvidos > 0 ? resolutionMinutesSum / resolvidos : 0;
  const firstResponseAvg = firstRespCount > 0 ? firstRespMinutesSum / firstRespCount : 0;
  const reopenRate = resolvidos > 0 ? percentage(reopenedTickets, resolvidos) : 0;
  const csatAvg = csatCount > 0 ? csatSum / csatCount : 0;

  const slaStatus: SummaryTone =
    slaPercent >= 90 ? "success" : slaPercent >= 75 ? "warning" : "danger";
  const resolutionStatus: SummaryTone =
    avgResolution <= 150 ? "success" : avgResolution <= 240 ? "warning" : "danger";
  const firstResponseStatus: SummaryTone =
    firstResponseAvg <= 15 ? "success" : firstResponseAvg <= 20 ? "warning" : "danger";
  const reopenStatus: SummaryTone =
    reopenRate <= 5 ? "success" : reopenRate <= 8 ? "warning" : "danger";
  const backlogStatus: SummaryTone = naoResolvidosAtuais <= recebidos * 0.1 ? "success" : "warning";
  const csatStatus: SummaryTone =
    csatAvg >= 85
      ? "success"
      : csatAvg >= 70
        ? "warning"
        : csatCount === 0
          ? "neutral"
          : "danger";

  return [
    {
      id: "tickets_periodo",
      label: "Tickets Recebidos",
      value: formatLargeNumber(recebidos),
      helper: "Criados no período considerando filtros",
      badge: undefined,
    },
    {
      id: "tickets_resolvidos",
      label: "Tickets Resolvidos",
      value: formatLargeNumber(resolvidos),
      helper: "Encerrados no período (resolved/closed)",
    },
    {
      id: "tickets_nao_resolvidos",
      label: "Tickets Não Resolvidos",
      value: formatLargeNumber(naoResolvidosAtuais),
      helper: "Todos os tickets ainda abertos atualmente",
      status: backlogStatus,
    },
    {
      id: "sla_resolucao",
      label: "% SLA de Resolução",
      value: formatPercent(slaPercent),
      helper: "Dentro do prazo entre tickets resolvidos no período",
      status: slaStatus,
    },
    {
      id: "tempo_resolucao",
      label: "Tempo Médio de Resolução",
      value: formatMinutesShort(avgResolution || 0),
      helper: "Abertura até resolved_at/closed_at",
      status: resolutionStatus,
    },
    {
      id: "tempo_primeira_resposta",
      label: "Tempo Médio 1ª Resposta",
      value: formatMinutesShort(firstResponseAvg || 0),
      helper: "Abertura até 1ª resposta do agente",
      status: firstResponseStatus,
    },
    {
      id: "taxa_reabertura",
      label: "Taxa de Reabertura",
      value: formatPercent(reopenRate || 0, 1),
      helper: "% de tickets com ao menos 1 reabertura entre os resolvidos",
      status: reopenStatus,
    },
    {
      id: "csat_medio",
      label: "CSAT Médio",
      value: csatAvg ? formatPercent(csatAvg) : "N/A",
      helper:
        csatAvg
          ? "Média das avaliações de satisfação (escala convertida para %)"
          : "Sem respostas de CSAT no período",
      status: csatStatus,
    },
  ];
}

// Distribuição genérica (status / urgência / prioridade)
const buildDistribution = (
  tickets: TicketBucket[],
  key: "status" | "urgency" | "priority",
  colors: Record<string, string>,
): SimpleDatum[] => {
  const map = new Map<string, number>();
  tickets.forEach(ticket => {
    const entry = (ticket as any)[key] as string;
    map.set(entry, (map.get(entry) ?? 0) + ticket.count);
  });
  return Array.from(map.entries()).map(([name, value]) => ({
    name,
    value,
    color: colors[name] ?? "#94a3b8",
  }));
};

const formatTrendLabel = (dateStr: string) => {
  const date = toDate(dateStr);
  // Formata como dia/mês para tendência diária
  return date.toLocaleDateString("pt-BR", { day: "2-digit", month: "short" });
};

const buildTrend = (tickets: TicketBucket[]) => {
  const map = new Map<string, number>();
  tickets.forEach(ticket => {
    map.set(ticket.date, (map.get(ticket.date) ?? 0) + ticket.count);
  });
  const entries = Array.from(map.entries()).sort(([a], [b]) => a.localeCompare(b));
  return entries.map(([date, value]) => ({
    name: formatTrendLabel(date),
    tickets: value,
  }));
};

interface AnalystMetrics {
  name: string;
  total: number;
  resolved: number;
  slaMet: number;
  reopened: number;
  avgResolution: number;
}

const buildAnalystMetrics = (tickets: TicketBucket[]): AnalystMetrics[] => {
  const map = new Map<string, AnalystMetrics>();
  tickets.forEach(ticket => {
    const current = map.get(ticket.analyst) ?? {
      name: ticket.analyst,
      total: 0,
      resolved: 0,
      slaMet: 0,
      reopened: 0,
      avgResolution: 0,
    };
    current.total += ticket.count;
    if (ticket.status === "resolved") {
      current.resolved += ticket.count;
      current.avgResolution += ticket.resolutionMinutes * ticket.count;
    }
    if (ticket.slaMet) current.slaMet += ticket.count;
    current.reopened += ticket.reopened;
    map.set(ticket.analyst, current);
  });

  return Array.from(map.values()).map(metric => ({
    ...metric,
    avgResolution: metric.resolved > 0 ? metric.avgResolution / metric.resolved : 0,
  }));
};

const summarizeCalls = (calls: CallBucket[]) =>
  calls.reduce(
    (acc, call) => {
      acc.total += call.count;
      
      // Para TMA: acumular duração apenas de chamadas atendidas (não abandonadas)
      // Se o bucket não tem flag abandoned, todas as chamadas são atendidas
      if (!call.abandoned) {
        acc.duration += call.durationMinutes * call.count;
      }
      
      // Contar chamadas abandonadas
      if (call.abandoned) {
        acc.abandoned += call.count;
      }
      return acc;
    },
    { total: 0, duration: 0, abandoned: 0 },
  );

const buildOperationalView = (
  tickets: TicketBucket[],
): OperationalData => {
  const status = buildDistribution(tickets, "status", statusColors);
  const urgency = buildDistribution(tickets, "urgency", urgencyColors);
  const priority = buildDistribution(tickets, "priority", priorityColors);
  const trend = buildTrend(tickets);

  const groupMap = new Map<
    string,
    { total: number; slaMet: number }
  >();
  tickets.forEach(ticket => {
    const current = groupMap.get(ticket.group) ?? { total: 0, slaMet: 0 };
    current.total += ticket.count;
    if (ticket.slaMet) current.slaMet += ticket.count;
    groupMap.set(ticket.group, current);
  });

  const sla = Array.from(groupMap.entries()).map(([name, data]) => ({
    name,
    value: Number(percentage(data.slaMet, data.total).toFixed(0)),
  }));
  const volume = Array.from(groupMap.entries()).map(([name, data]) => ({
    name,
    value: data.total,
  }));

  const analystMetrics = buildAnalystMetrics(tickets).sort(
    (a, b) => b.resolved - a.resolved,
  );

  const topAnalysts: SimpleDatum[] = analystMetrics.slice(0, 5).map(metric => ({
    name: metric.name,
    value: metric.resolved,
  }));

  const leaderboard: LeaderboardEntry[] = analystMetrics.slice(0, 3).map(metric => ({
    name: metric.name,
    resolved: metric.resolved,
    sla: Number(percentage(metric.slaMet, metric.total).toFixed(0)),
    avgTime: formatMinutesShort(metric.avgResolution),
  }));

  const analystsTable: AnalystDetail[] = analystMetrics.slice(0, 5).map(metric => ({
    name: metric.name,
    resolved: metric.resolved,
    sla: Number(percentage(metric.slaMet, metric.total).toFixed(0)),
    reopened: metric.reopened,
  }));

  return {
    status,
    urgency,
    priority,
    trend,
    sla,
    volume,
    topAnalysts,
    leaderboard,
    analystsTable,
  };
};

const buildServiceCards = (
  tickets: TicketBucket[],
  ticketSummary: TicketSummary,
  callSummary: { total: number; duration: number; abandoned: number },
): SummaryCard[] => {
  const totalTickets = ticketSummary.total;

  // Tickets resolvidos (com resolved_at/closed_at e tempo de resolução válido)
  const ticketsResolvidos = ticketSummary.resolved;

  // Tickets não resolvidos (backlog aproximado para o período)
  const baselineTotal = tickets.reduce((sum, item) => sum + item.count, 0);
  const backlogValue = Math.max(0, baselineTotal - ticketsResolvidos);

  // % SLA resolução (dentro do prazo entre os resolvidos)
  const slaPercent = ticketsResolvidos > 0
    ? percentage(ticketSummary.slaMet, ticketsResolvidos)
    : 0;

  // Tempo médio de resolução (minutos) apenas para resolvidos
  const avgResolution =
    ticketsResolvidos > 0 ? ticketSummary.resolutionMinutes / ticketsResolvidos : 0;

  // Tempo médio 1ª resposta (minutos) somente quando existe first_responded_at
  const ticketsComPrimeiraResposta = tickets.reduce((sum, t) => {
    return sum + (t.firstResponseMinutes > 0 ? t.count : 0);
  }, 0);
  const firstResponseAvg =
    ticketsComPrimeiraResposta > 0
      ? ticketSummary.firstResponseMinutes / ticketsComPrimeiraResposta
      : 0;

  // Taxa de reabertura: tickets reabertos / resolvidos
  const reopenRate = ticketsResolvidos > 0
    ? percentage(ticketSummary.reopened, ticketsResolvidos)
    : 0;

  // CSAT Médio
  const csatAvg = ticketSummary.csatCount > 0
    ? ticketSummary.csatSum / ticketSummary.csatCount
    : 0;

  const slaStatus: SummaryTone =
    slaPercent >= 90 ? "success" : slaPercent >= 75 ? "warning" : "danger";
  const resolutionStatus: SummaryTone =
    avgResolution <= 150 ? "success" : avgResolution <= 240 ? "warning" : "danger";
  const firstResponseStatus: SummaryTone =
    firstResponseAvg <= 15 ? "success" : firstResponseAvg <= 20 ? "warning" : "danger";
  const reopenStatus: SummaryTone =
    reopenRate <= 5 ? "success" : reopenRate <= 8 ? "warning" : "danger";
  const backlogStatus: SummaryTone =
    backlogValue <= baselineTotal * 0.1 ? "success" : "warning";
  const csatStatus: SummaryTone =
    csatAvg >= 85 ? "success" : csatAvg >= 70 ? "warning" : ticketSummary.csatCount === 0 ? "neutral" : "danger";

  return [
    {
      id: "tickets_periodo",
      label: "Tickets Recebidos",
      value: formatLargeNumber(totalTickets),
      helper: "Criados no período considerando filtros",
      badge: undefined,
    },
    {
      id: "tickets_resolvidos",
      label: "Tickets Resolvidos",
      value: formatLargeNumber(ticketsResolvidos),
      helper: "Encerrados no período (resolved/closed)",
    },
    {
      id: "tickets_nao_resolvidos",
      label: "Tickets Não Resolvidos",
      value: formatLargeNumber(backlogValue),
      helper: "Abertos/pendentes para o período",
      status: backlogStatus,
    },
    {
      id: "sla_resolucao",
      label: "% SLA de Resolução",
      value: formatPercent(slaPercent),
      helper: "Dentro do prazo entre tickets resolvidos",
      status: slaStatus,
    },
    {
      id: "tempo_resolucao",
      label: "Tempo Médio de Resolução",
      value: formatMinutesShort(avgResolution),
      helper: "Diferença entre abertura e resolução",
      status: resolutionStatus,
    },
    {
      id: "tempo_primeira_resposta",
      label: "Tempo Médio 1ª Resposta",
      value: formatMinutesShort(firstResponseAvg),
      helper: "Abertura até 1ª resposta do agente",
      status: firstResponseStatus,
    },
    {
      id: "taxa_reabertura",
      label: "Taxa de Reabertura",
      value: formatPercent(reopenRate),
      helper: "Tickets com ao menos 1 reabertura",
      status: reopenStatus,
    },
    {
      id: "csat_medio",
      label: "CSAT Médio",
      value: ticketSummary.csatCount > 0 ? formatPercent(csatAvg) : "N/A",
      helper: ticketSummary.csatCount > 0 ? "Média das avaliações de satisfação" : "Sem respostas no período",
      status: csatStatus,
    },
  ];
};

// ...
const buildMetrics = (
  ticketSummary: TicketSummary,
  callSummary: { total: number; duration: number; abandoned: number },
): Metric[] => {
  const totalTickets = ticketSummary.total;
  const csatAvg = ticketSummary.csatCount > 0 ? ticketSummary.csatSum / ticketSummary.csatCount : 0;
  const slaResolution = percentage(ticketSummary.slaMet, totalTickets);
  const firstReply = percentage(ticketSummary.firstResponseMet, totalTickets);
  const avgResolution =
    ticketSummary.resolved > 0 ? ticketSummary.resolutionMinutes / ticketSummary.resolved : 0;
  // TMA: Tempo Médio de Atendimento - apenas chamadas atendidas (não abandonadas)
  const chamadasAtendidas = callSummary.total - callSummary.abandoned;
  const callAvg = chamadasAtendidas > 0 ? callSummary.duration / chamadasAtendidas : 0;
  
  // Taxa de Abandono: chamadas abandonadas / total de chamadas
  const callAbandonment = percentage(callSummary.abandoned, callSummary.total);

  return [
    {
      id: "tickets-total",
      label: "Tickets Processados",
      value: totalTickets,
      formatter: "integer",
      description: "Chamados filtrados",
      source: "freshservice",
    },
    {
      id: "csat",
      label: "CSAT Geral",
      value: csatAvg,
      formatter: "percent",
      target: 85,
      goalDirection: "above",
      description:
        ticketSummary.csatCount > 0 ? "Base CSAT do período" : "Sem respostas no período",
      displayValue: ticketSummary.csatCount > 0 ? undefined : "N/A",
      source: "freshservice",
    },
    {
      id: "sla-resolution",
      label: "SLA Resolução",
      value: slaResolution,
      formatter: "percent",
      target: 90,
      goalDirection: "above",
      description: "Meta operacional 90%",
      source: "freshservice",
    },
    {
      id: "sla-first-response",
      label: "SLA 1º Atendimento",
      value: firstReply,
      formatter: "percent",
      target: 95,
      goalDirection: "above",
      description: "Meta global 95%",
      source: "freshservice",
    },
    {
      id: "resolution-avg",
      label: "Tempo Médio de Resolução",
      value: avgResolution,
      formatter: "duration",
      displayValue: formatMinutesShort(avgResolution),
      description: "Tickets resolvidos",
      target: 120,
      goalDirection: "below",
      source: "freshservice",
    },
    {
      id: "calls-total",
      label: "Total de Ligações",
      value: callSummary.total,
      formatter: "integer",
      description: "Telefonia Zenvia",
    },
    {
      id: "tma",
      label: "TMA (Tempo Médio)",
      value: callAvg,
      formatter: "duration",
      displayValue: formatMinutesShort(callAvg),
      description: "Meta < 60 min",
      target: 60,
      goalDirection: "below",
    },
    {
      id: "abandonment",
      label: "Taxa de Abandono",
      value: callAbandonment,
      formatter: "percent",
      target: 5,
      goalDirection: "below",
      description: "Limite 5%",
    },
  ];
};

// Mapeamentos para transformar tickets raw em buckets
const STATUS_MAP: Record<number, "resolved" | "pending" | "sla_breach"> = {
  // 2 = Open, 3 = Pending, 6 = Waiting on Customer (considerar pendentes aqui)
  2: "pending",
  3: "pending",
  6: "pending",
  // 4 = Resolved, 5 = Closed (contam como resolvidos)
  4: "resolved",
  5: "resolved",
  // 9 e outros códigos de resolved/closed customizados também como resolvidos
  9: "resolved",
};

const PRIORITY_MAP: Record<number, "Baixa" | "Média" | "Alta" | "Urgente"> = {
  1: "Baixa",
  2: "Média",
  3: "Alta",
  4: "Urgente",
};

const GROUP_MAP: Record<number, "Suporte" | "Field" | "NOC" | "Delivery"> = {
  37000043862: "Suporte",
  37000153628: "Field",
  37000171279: "NOC",
  37000175476: "Delivery",
};

// Função para transformar tickets raw em TicketBucket[]
function transformTicketsToBuckets(
  rawTickets: RawTicket[],
  agents: Agent[],
  groups: Group[],
): TicketBucket[] {
  const agentMap = new Map<number, string>();
  agents.forEach(agent => {
    agentMap.set(agent.id, agent.name);
  });

  const groupMap = new Map<number, string>();
  groups.forEach(group => {
    groupMap.set(group.id, group.name);
  });

  const buckets = new Map<string, TicketBucket>();

  rawTickets.forEach(ticket => {
    const date = ticket.created_at.split("T")[0];
    const analystName = ticket.responder_id
      ? agentMap.get(ticket.responder_id) || "Não atribuído"
      : "Não atribuído";

    // Mapear grupo
    let groupName: "Suporte" | "Field" | "NOC" | "Delivery" = "Suporte";
    if (ticket.group_id && GROUP_MAP[ticket.group_id]) {
      groupName = GROUP_MAP[ticket.group_id];
    } else if (ticket.group_id) {
      const group = groups.find(g => g.id === ticket.group_id);
      if (group) {
        const nameLower = group.name.toLowerCase();
        if (nameLower.includes("field")) groupName = "Field";
        else if (nameLower.includes("noc") || nameLower.includes("alerta")) groupName = "NOC";
        else if (nameLower.includes("delivery") || nameLower.includes("backoffice")) groupName = "Delivery";
        else groupName = "Suporte";
      }
    }

    const status = STATUS_MAP[ticket.status] || "pending";
    const priority = PRIORITY_MAP[ticket.priority] || "Média";
    const urgency = PRIORITY_MAP[ticket.priority] || "Média";

    // Calcular minutos entre datas
    const minutesBetween = (start: string, end: string): number => {
      if (!start || !end) return 0;
      const startDate = new Date(start);
      const endDate = new Date(end);
      return Math.round((endDate.getTime() - startDate.getTime()) / (1000 * 60));
    };

    // HDI: Calcular primeira resposta (apenas se existir)
    const firstResponseMinutes = ticket.first_responded_at
      ? minutesBetween(ticket.created_at, ticket.first_responded_at)
      : 0;

    // HDI: Verificar primeira resposta dentro do SLA
    const checkFirstResponseMet = (): boolean => {
      if (!ticket.fr_due_by || !ticket.first_responded_at) return false;
      const frDue = new Date(ticket.fr_due_by);
      const firstResp = new Date(ticket.first_responded_at);
      return firstResp <= frDue;
    };

    // HDI: Calcular resolução (apenas se existir)
    const resolvedAt = ticket.resolved_at || ticket.closed_at;
    const resolutionMinutes = resolvedAt
      ? minutesBetween(ticket.created_at, resolvedAt)
      : 0;

    // HDI: Verificar SLA de resolução
    const checkSlaMet = (): boolean => {
      if (!ticket.due_by || !resolvedAt) return false;
      const due = new Date(ticket.due_by);
      const resolved = new Date(resolvedAt);
      return resolved <= due;
    };

    const bucketKey = `${date}-${analystName}-${groupName}-${status}-${priority}`;

    if (!buckets.has(bucketKey)) {
      buckets.set(bucketKey, {
        id: bucketKey,
        date,
        analyst: analystName,
        group: groupName,
        status,
        priority,
        urgency,
        slaMet: checkSlaMet(),
        firstResponseMinutes: 0,
        firstResponseMet: checkFirstResponseMet(),
        resolutionMinutes: 0,
        reopened: ticket.reopened_count || 0,
        csatScore: ticket.custom_fields?.cf_csat_rating,
        count: 0,
      });
    }

    const bucket = buckets.get(bucketKey)!;
    bucket.count += 1;
    if (firstResponseMinutes > 0) {
      bucket.firstResponseMinutes += firstResponseMinutes;
    }
    if (resolutionMinutes > 0) {
      bucket.resolutionMinutes += resolutionMinutes;
    }
  });

  return Array.from(buckets.values());
}

const buildComputedView = (
  tickets: TicketBucket[],
  calls: CallBucket[],
): ComputedView => {
  // Garantir que sempre temos arrays válidos
  const safeTickets = Array.isArray(tickets) ? tickets : [];
  const safeCalls = Array.isArray(calls) ? calls : [];

  const ticketSummary = summarizeTickets(safeTickets);
  const callSummary = summarizeCalls(safeCalls);

  const serviceCards = buildServiceCards(safeTickets, ticketSummary, callSummary);
  const metrics = buildMetrics(ticketSummary, callSummary);
  const operational = buildOperationalView(safeTickets);

  // Garantir que sempre retornamos um objeto completo, nunca null/undefined
  return {
    serviceCards: Array.isArray(serviceCards) ? serviceCards : [],
    metrics: Array.isArray(metrics) ? metrics : [],
    operational: operational || {
      status: [],
      urgency: [],
      priority: [],
      trend: [],
      sla: [],
      volume: [],
      topAnalysts: [],
      leaderboard: [],
      analystsTable: [],
    },
  };
};

function FilterField({
  label,
  children,
}: {
  label: string;
  children: React.ReactNode;
}) {
  return (
    <label className="flex flex-col gap-2">
      <span className="text-xs font-semibold uppercase tracking-[0.15em] text-slate-500">{label}</span>
      <div className="text-base font-normal tracking-normal">{children}</div>
    </label>
  );
}

export default function DashboardOverview({ view = "full" }: { view?: DashboardView }) {
  // Estados de credenciais
  const [credentials, setCredentials] = useState<{
  freshserviceApiKey: string;
  freshserviceDomain: string;
  zenviaApiToken: string;
} | null>(() => {
  const envDomain = (import.meta as any).env?.VITE_FRESHSERVICE_DOMAIN as string | undefined;
  const envKey = (import.meta as any).env?.VITE_FRESHSERVICE_API_KEY as string | undefined;

  const domain = (envDomain || localStorage.getItem("freshservice_domain") || "").trim();
  const apiKey = (envKey || localStorage.getItem("freshservice_api_key") || "").trim();

  if (!domain || !apiKey) return null;
  return {
    freshserviceApiKey: apiKey,
    freshserviceDomain: domain,
    zenviaApiToken: "",
  };
});

  // Estados de filtros - padrão: hoje
  const today = new Date().toISOString().split("T")[0];
  const [startDate, setStartDate] = useState<string>(today);
  const [endDate, setEndDate] = useState<string>(today);
  const [selectedGroup, setSelectedGroup] = useState<"Todos" | string>("Todos");
  const [activeQuickRange, setActiveQuickRange] = useState<string>("");

  // Usar hook simplificado para grupos, agentes, tickets e chamadas
  const { isLoading: isLoadingData, error: dataError, groups, agents, tickets, calls } = useRealDashboardData(
    {
      startDate,
      endDate,
      groupId: selectedGroup,
      agentId: "Todos",
    },
    credentials,
  );

  // Usar hook de métricas modulares (nova rota /api/metrics) - buscar apenas ao clicar
  const { isLoading: isLoadingMetrics, error: metricsError, metrics, fetchMetrics } = useMetrics({
    startDate,
    endDate,
    groupId: selectedGroup,
    agentId: "Todos",
    autoFetch: false,
  });

  // Usar hook de métricas HDI para dados operacionais reais (buscar apenas ao clicar)
  const { data: hdiData, isLoading: isLoadingHdi, fetchMetrics: fetchHdiMetrics } = useHdiMetrics({
    startDate,
    endDate,
    groupId: selectedGroup,
    agentId: "Todos",
    autoFetch: false,
  });

  const isLoading = isLoadingData || isLoadingMetrics || isLoadingHdi;
  const error = dataError || metricsError;

  // Transformar tickets raw em buckets
  const ticketBuckets = useMemo(() => {
    return transformTicketsToBuckets(tickets as RawTicket[], agents, groups);
  }, [tickets, agents, groups]);

  // Transformar chamadas raw em CallBucket[]
  const callBuckets = useMemo(() => {
    if (!calls || !Array.isArray(calls)) return [];
    
    const buckets = new Map<string, CallBucket>();
    
    calls.forEach(call => {
      const date = call.startedAt ? call.startedAt.split("T")[0] : new Date().toISOString().split("T")[0];
      const analyst = "Não atribuído"; // Zenvia pode não ter informação de analista
      const durationMinutes = call.durationSeconds / 60;
      const abandoned = call.abandoned || false;
      
      const bucketKey = `${date}-${analyst}`;
      
      if (!buckets.has(bucketKey)) {
        buckets.set(bucketKey, {
          id: bucketKey,
          date,
          analyst,
          durationMinutes: 0,
          abandoned,
          count: 0,
        });
      }
      
      const bucket = buckets.get(bucketKey)!;
      bucket.count += 1;
      if (!abandoned) {
        bucket.durationMinutes += durationMinutes;
      }
    });
    
    return Array.from(buckets.values());
  }, [calls]);

  // Handler para mudança de grupo (sem dependência de filtro de agente na visão geral)
  function handleChangeGroup(e: React.ChangeEvent<HTMLSelectElement>) {
    const newGroup = e.target.value || "Todos";
    setSelectedGroup(newGroup);
  }

  function handleAplicarFiltros() {
    if (!startDate || !endDate) {
      alert("Preencha Data Início e Data Fim.");
      return;
    }

    if (startDate > endDate) {
      alert("Data Início não pode ser maior que Data Fim.");
      return;
    }
    // Buscar todas as métricas ao clicar em Buscar
    fetchMetrics();
    fetchHdiMetrics();
  }

  function handleQuickRange(range: "today" | "7" | "15" | "30") {
    const today = new Date();
    const end = formatDateInput(today);

    setActiveQuickRange(range);

    if (range === "today") {
      setStartDate(end);
      setEndDate(end);
      return;
    }

    const days = Number(range);
    const startDateObj = new Date(today);
    startDateObj.setDate(startDateObj.getDate() - (days - 1));
    const start = formatDateInput(startDateObj);

    setStartDate(start);
    setEndDate(end);
  }

  const computed = useMemo(
    () => buildComputedView(ticketBuckets, callBuckets),
    [ticketBuckets, callBuckets],
  );

  // Dados operacionais reais do HDI (substituir os dados calculados localmente)
  const realOperationalData = useMemo(() => {
    if (!hdiData) return null;

    // Distribuição por status (calculado a partir dos tickets)
    const totalTickets = hdiData.totalTickets || 0;
    const backlog = hdiData.backlog || 0;
    const resolved = totalTickets - backlog;
    
    const status: SimpleDatum[] = [
      { name: "Resolvidos", value: resolved },
      { name: "Pendentes", value: backlog },
    ];

    // Distribuição por prioridade (vem do backend)
    const priority: SimpleDatum[] = hdiData.priorityDistribution || [];

    // Distribuição por urgência (usar mesma distribuição de prioridade)
    const urgency: SimpleDatum[] = hdiData.priorityDistribution || [];

    // SLA por grupo
    const slaWithin = hdiData.slaDonut?.within || 0;
    const slaBreached = hdiData.slaDonut?.breached || 0;
    const slaTotal = slaWithin + slaBreached;
    const slaPercent = slaTotal > 0 ? Math.round((slaWithin / slaTotal) * 100) : 0;
    
    const sla: SimpleDatum[] = [
      { name: selectedGroup === "Todos" ? "Geral" : groups.find(g => String(g.id) === selectedGroup)?.name || "Grupo", value: slaPercent },
    ];

    // Volume por grupo
    const volume: SimpleDatum[] = [
      { name: selectedGroup === "Todos" ? "Geral" : groups.find(g => String(g.id) === selectedGroup)?.name || "Grupo", value: totalTickets },
    ];

    return {
      status,
      priority,
      urgency,
      sla,
      volume,
    };
  }, [hdiData, selectedGroup, groups]);

  // Service cards usando métricas do backend (nova rota /api/metrics)
  const serviceCards = useMemo((): SummaryCard[] => {
    if (!metrics) {
      return buildServiceCardsFromRaw(tickets as RawTicket[], startDate, endDate);
    }

    // Usar configuração de SLA do grupo (vem do backend)
    const defaultSlaConfig = { 
      firstResponse: 15, 
      resolution: { urgente: 120, alta: 240, media: 1440, baixa: 4320 } 
    };
    const slaConfig = metrics.slaConfig || defaultSlaConfig;
    const avgResolutionTarget = slaConfig.resolution?.media || 1440; // usar prioridade média como referência
    
    const slaStatus: SummaryTone =
      metrics.slaResolucao >= 90 ? "success" : metrics.slaResolucao >= 75 ? "warning" : "danger";
    const resolutionStatus: SummaryTone =
      metrics.tempoMedioResolucao <= avgResolutionTarget * 0.5 ? "success" : 
      metrics.tempoMedioResolucao <= avgResolutionTarget ? "warning" : "danger";
    const firstResponseStatus: SummaryTone =
      metrics.tempoMedioPrimeiraResposta <= slaConfig.firstResponse ? "success" : 
      metrics.tempoMedioPrimeiraResposta <= slaConfig.firstResponse * 2 ? "warning" : "danger";
    const reopenStatus: SummaryTone =
      metrics.taxaReabertura <= 5 ? "success" : metrics.taxaReabertura <= 8 ? "warning" : "danger";
    const backlogStatus: SummaryTone =
      metrics.ticketsNaoResolvidos <= metrics.ticketsRecebidos * 0.1 ? "success" : "warning";
    const csatStatus: SummaryTone =
      metrics.csatMedio >= 85 ? "success" : metrics.csatMedio >= 70 ? "warning" : metrics.csatCount === 0 ? "neutral" : "danger";

    // Calcular taxa de resolução no primeiro contato (FCR)
    const fcrRate = metrics.ticketsRecebidos > 0 
      ? ((metrics.ticketsResolvidos / metrics.ticketsRecebidos) * 100)
      : 0;
    const fcrStatus: SummaryTone = fcrRate >= 70 ? "success" : fcrRate >= 50 ? "warning" : "danger";

    // Calcular SLA de primeira resposta (baseado na meta de 15 min)
    const slaFirstResponseRate = metrics.tempoMedioPrimeiraResposta <= slaConfig.firstResponse ? 100 :
      metrics.tempoMedioPrimeiraResposta <= slaConfig.firstResponse * 2 ? 80 : 60;
    const slaFirstResponseStatus: SummaryTone = slaFirstResponseRate >= 90 ? "success" : slaFirstResponseRate >= 75 ? "warning" : "danger";

    // Linha 1: Tickets recebidos, Não resolvidos, Resolvidos, FCR
    // Linha 2: SLA Resolução, Tempo Resolução, SLA 1ª Resposta, Tempo 1ª Resposta
    return [
      // Linha 1
      {
        id: "tickets_periodo",
        label: "Tickets recebidos",
        value: formatLargeNumber(metrics.ticketsRecebidos),
        helper: "Tickets recebidos no período selecionado",
        row: 1,
      },
      {
        id: "tickets_nao_resolvidos",
        label: "Tickets não resolvidos",
        value: formatLargeNumber(metrics.ticketsNaoResolvidos),
        helper: "Tickets em backlog (não resolvidos)",
        status: backlogStatus,
        row: 1,
      },
      {
        id: "tickets_resolvidos",
        label: "Tickets resolvidos",
        value: formatLargeNumber(metrics.ticketsResolvidos),
        helper: "Status resolvido no período selecionado",
        row: 1,
      },
      {
        id: "fcr",
        label: "Taxa de resolução no primeiro contato",
        value: formatPercent(fcrRate),
        helper: "% de tickets resolvidos vs recebidos",
        status: fcrStatus,
        row: 1,
      },
      // Linha 2
      {
        id: "sla_resolucao",
        label: "Conformidade com SLA de resolução",
        value: formatPercent(metrics.slaResolucao),
        helper: "Dentro do prazo entre tickets resolvidos",
        status: slaStatus,
        row: 2,
      },
      {
        id: "tempo_resolucao",
        label: "Tempo médio de resolução",
        value: formatMinutesShort(metrics.tempoMedioResolucao),
        helper: `Meta: ${formatMinutesShort(slaConfig.resolution?.media || 1440)}`,
        status: resolutionStatus,
        row: 2,
      },
      {
        id: "sla_primeira_resposta",
        label: "Conformidade com o SLA de primeira resposta",
        value: formatPercent(slaFirstResponseRate),
        helper: `Meta: ${slaConfig.firstResponse || 15} minutos`,
        status: slaFirstResponseStatus,
        row: 2,
      },
      {
        id: "tempo_primeira_resposta",
        label: "Tempo Médio de Primeira Resposta",
        value: formatMinutesShort(metrics.tempoMedioPrimeiraResposta),
        helper: `Meta: ${slaConfig.firstResponse || 15} minutos`,
        status: firstResponseStatus,
        row: 2,
      },
    ];
  }, [metrics, tickets, startDate, endDate]);

  const showOverviewCards = view === "overview" || view === "full";
  const showKpis = false;
  const showOperational = view === "overview" || view === "full";
  const showEquipe = view === "equipe" || view === "full";
  const showTelefonia = false;


        {true && (
    <div className="min-h-screen">
      
      {isLoading && (
        <div className="flex min-h-screen items-center justify-center bg-gray-50">
          <div className="text-center">
            <div className="mb-4 h-12 w-12 animate-spin rounded-full border-4 border-slate-200 border-t-slate-900 mx-auto" />
            <p className="text-lg font-semibold text-slate-600">Carregando dados...</p>
          </div>
        </div>
      )}


      {true && (
      <div className="mx-auto max-w-6xl px-4 pb-20 pt-6 sm:px-6 lg:px-8 space-y-6">
        {/* Header com Filtros Integrados */}
        <motion.div
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.4 }}
          className="rounded-2xl bg-gradient-to-br from-blue-800 via-blue-700 to-cyan-800 p-6 text-white shadow-xl"
        >
          <div className="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-6">
            {/* Título */}
            <div className="flex items-center gap-4">
              <div className="flex h-12 w-12 items-center justify-center rounded-xl bg-white/10 backdrop-blur">
                <LayoutDashboard className="h-6 w-6 text-cyan-300" />
              </div>
              <div>
                <h1 className="text-2xl font-bold text-white">Painel Operacional</h1>
                <p className="text-sm text-blue-100">Visualize e analise os dados do período</p>
              </div>
            </div>

            {/* Filtros Inline */}
            <div className="flex flex-wrap items-center gap-3">
              {/* Período Rápido */}
              <div className="flex rounded-lg bg-white/10 p-1">
                {[
                  { key: "today", label: "Hoje" },
                  { key: "7", label: "7 dias" },
                  { key: "15", label: "15 dias" },
                  { key: "30", label: "30 dias" },
                ].map(({ key, label }) => (
                  <button
                    key={key}
                    onClick={() => handleQuickRange(key as "today" | "7" | "15" | "30")}
                    className={`rounded-md px-3 py-1.5 text-xs font-medium transition-all ${
                      activeQuickRange === key
                        ? "bg-white text-blue-900 shadow"
                        : "text-blue-200 hover:text-white hover:bg-white/10"
                    }`}
                  >
                    {label}
                  </button>
                ))}
              </div>

              {/* Datas */}
              <div className="flex items-center gap-2 rounded-lg bg-white/10 px-3 py-1.5">
                <Calendar className="h-4 w-4 text-blue-300" />
                <input
                  type="date"
                  value={startDate}
                  onChange={(e) => { setStartDate(e.target.value); setActiveQuickRange(""); }}
                  className="bg-transparent text-sm text-white border-none outline-none w-28 [color-scheme:dark]"
                />
                <span className="text-blue-400">→</span>
                <input
                  type="date"
                  value={endDate}
                  onChange={(e) => { setEndDate(e.target.value); setActiveQuickRange(""); }}
                  className="bg-transparent text-sm text-white border-none outline-none w-28 [color-scheme:dark]"
                />
              </div>

              {/* Grupo */}
              <div className="flex items-center gap-2 rounded-lg bg-white/10 px-3 py-1.5">
                <Users className="h-4 w-4 text-blue-300" />
                <select
                  value={selectedGroup}
                  onChange={handleChangeGroup}
                  className="bg-transparent text-sm text-white border-none outline-none cursor-pointer"
                >
                  <option value="Todos" className="text-slate-900">Todos os Grupos</option>
                  {groups
                    .filter((group) => {
                      const allowedGroups = [
                        "suporte",
                        "data center",
                        "datacenter",
                        "delivery",
                        "registros de ligações",
                        "registros de ligacoes",
                        "qualidade",
                        "suporte interno"
                      ];
                      return allowedGroups.some(allowed => 
                        group.name.toLowerCase().includes(allowed)
                      );
                    })
                    .map((group) => (
                      <option key={group.id} value={String(group.id)} className="text-slate-900">
                        {group.name}
                      </option>
                    ))
                  }
                </select>
              </div>

              {/* Botão Buscar */}
              <button
                onClick={handleAplicarFiltros}
                disabled={isLoading}
                className="flex items-center gap-2 rounded-lg bg-cyan-500 px-4 py-2 text-sm font-semibold text-white shadow-lg shadow-cyan-500/25 hover:bg-cyan-400 transition-all disabled:opacity-50"
              >
                <Search className="h-4 w-4" />
                {isLoading ? "Buscando..." : "Buscar"}
              </button>
            </div>
          </div>

          {/* Info do período */}
          <div className="mt-4 flex items-center gap-2 text-xs text-blue-300">
            <Calendar className="h-3.5 w-3.5" />
            <span>Período: {new Date(startDate + "T12:00:00").toLocaleDateString("pt-BR", { day: "2-digit", month: "short", year: "numeric" })} até {new Date(endDate + "T12:00:00").toLocaleDateString("pt-BR", { day: "2-digit", month: "short", year: "numeric" })}</span>
            {selectedGroup !== "Todos" && (
              <>
                <span className="mx-2">•</span>
                <Users className="h-3.5 w-3.5" />
                <span>Grupo: {groups.find(g => String(g.id) === selectedGroup)?.name}</span>
              </>
            )}
          </div>
        </motion.div>

        {/* Aviso de performance */}
        <div className="flex items-center gap-2 rounded-lg bg-amber-50 border border-amber-200 px-4 py-2 text-xs text-amber-700">
          <AlertTriangle className="h-4 w-4 text-amber-500" />
          <span>Para melhor desempenho, evite buscas com períodos acima de 30 dias.</span>
        </div>

        {/* Alerta de erro genérico quando não for possível carregar dados */}
        {error && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            className="mt-6 rounded-lg bg-amber-50 border border-amber-200 px-4 py-3"
          >
            <p className="text-sm font-semibold text-amber-800">
              Erro ao carregar dados do Freshservice: {error}
            </p>
          </motion.div>
        )}

        {showOverviewCards && (
        <motion.section
          initial={{ opacity: 0, y: 24 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.1, duration: 0.5 }}
          className="space-y-4"
        >
          {/* Linha 1: 4 cards */}
          <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-4">
            {serviceCards.filter(c => c.row === 1).map(card => (
              <div
                key={card.id}
                className="group relative h-28 [perspective:1000px]"
              >
                {/* Container do flip */}
                <div className="relative h-full w-full transition-transform duration-500 [transform-style:preserve-3d] group-hover:[transform:rotateY(180deg)]">
                  {/* Frente do card */}
                  <div className="absolute inset-0 rounded-2xl border border-slate-200 bg-white p-5 shadow-sm [backface-visibility:hidden]">
                    <p className="text-xs font-medium text-slate-500 mb-3">
                      {card.label}
                    </p>
                    <div className="flex items-baseline gap-2">
                      <p className="text-2xl font-bold text-slate-900">{card.value}</p>
                      {card.status && (
                        <span className={`text-xs font-semibold ${
                          card.status === "success" ? "text-emerald-600" : 
                          card.status === "warning" ? "text-amber-600" : 
                          card.status === "danger" ? "text-red-600" : "text-slate-500"
                        }`}>
                          {card.status === "success" ? "↑" : card.status === "danger" ? "↓" : "→"}
                        </span>
                      )}
                    </div>
                  </div>
                  {/* Verso do card - informações explicativas */}
                  <div className="absolute inset-0 rounded-2xl border border-blue-200 bg-blue-50 p-4 shadow-sm [backface-visibility:hidden] [transform:rotateY(180deg)] flex flex-col justify-center">
                    <p className="text-xs font-semibold text-blue-900 mb-1">{card.label}</p>
                    <p className="text-xs text-blue-700 leading-relaxed">{card.helper}</p>
                  </div>
                </div>
              </div>
            ))}
          </div>
          
          {/* Linha 2: 4 cards */}
          <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-4">
            {serviceCards.filter(c => c.row === 2).map(card => (
              <div
                key={card.id}
                className="group relative h-28 [perspective:1000px]"
              >
                {/* Container do flip */}
                <div className="relative h-full w-full transition-transform duration-500 [transform-style:preserve-3d] group-hover:[transform:rotateY(180deg)]">
                  {/* Frente do card */}
                  <div className="absolute inset-0 rounded-2xl border border-slate-200 bg-white p-5 shadow-sm [backface-visibility:hidden]">
                    <p className="text-xs font-medium text-slate-500 mb-3">
                      {card.label}
                    </p>
                    <div className="flex items-baseline gap-2">
                      <p className="text-2xl font-bold text-slate-900">{card.value}</p>
                      {card.status && (
                        <span className={`text-xs font-semibold ${
                          card.status === "success" ? "text-emerald-600" : 
                          card.status === "warning" ? "text-amber-600" : 
                          card.status === "danger" ? "text-red-600" : "text-slate-500"
                        }`}>
                          {card.status === "success" ? "↑" : card.status === "danger" ? "↓" : "→"}
                        </span>
                      )}
                    </div>
                  </div>
                  {/* Verso do card - informações explicativas */}
                  <div className="absolute inset-0 rounded-2xl border border-blue-200 bg-blue-50 p-4 shadow-sm [backface-visibility:hidden] [transform:rotateY(180deg)] flex flex-col justify-center">
                    <p className="text-xs font-semibold text-blue-900 mb-1">{card.label}</p>
                    <p className="text-xs text-blue-700 leading-relaxed">{card.helper}</p>
                  </div>
                </div>
              </div>
            ))}
          </div>
          
          <p className="text-xs text-slate-400 mt-4">
            Passe o cursor sobre os cards para ver informações detalhadas.
          </p>
        </motion.section>
        )}


        {showKpis && (
        <section className="mt-12 space-y-6">
          <div className="flex flex-wrap items-center justify-between gap-4">
            <div>
              <p className="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400">
                Principais Métricas
              </p>
              <h2 className="mt-2 text-3xl font-semibold text-slate-900">
                KPIs críticos monitorados em tempo real
              </h2>
              <p className="mt-2 max-w-3xl text-base text-slate-600">Análise detalhada dos dados do período selecionado</p>
            </div>
            <div className="flex items-center gap-2 rounded-full border border-slate-200 bg-white px-4 py-2 text-sm text-slate-500">
              <Info className="h-4 w-4 text-slate-400" />
              Fonte: Freshservice + Zenvia
            </div>
          </div>
          <div className="relative">
            {/* Grid estilo bento em telas médias/grandes */}
            <div className="hidden md:grid gap-6 md:grid-cols-2 xl:grid-cols-3">
              {computed.metrics.map(metric => (
                <KPICard key={metric.id} metric={metric} />
              ))}
            </div>

            {/* Carrossel horizontal em telas pequenas */}
            <div className="md:hidden -mx-4 overflow-x-auto pb-2">
              <div className="flex gap-4 px-1 snap-x snap-mandatory">
                {computed.metrics.map(metric => (
                  <div
                    key={metric.id}
                    className="min-w-[260px] max-w-[280px] snap-center"
                  >
                    <KPICard metric={metric} />
                  </div>
                ))}
              </div>
            </div>
          </div>
        </section>
        )}

        {showOperational && (
        <section className="mt-12 space-y-6">
          <div className="flex flex-wrap items-center justify-between gap-4">
            <div>
              <p className="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400">
                Visão Operacional
              </p>
              <h2 className="mt-2 text-3xl font-semibold text-slate-900">
                Distribuição de tickets e performance por grupo
              </h2>
            </div>
            <span className="text-sm text-slate-500">Atualizado em {new Date().toLocaleString("pt-BR", { dateStyle: "long", timeStyle: "short" })}</span>
          </div>
          <div className="grid gap-6 lg:grid-cols-2">
            <ChartCard title="Suportes por Status" subtitle="Operação Freshservice">
              <DistributionBarChart data={realOperationalData?.status || computed.operational.status} />
            </ChartCard>
            <ChartCard title="Suportes por Urgência" subtitle="Fila consolidada">
              <DistributionBarChart data={realOperationalData?.urgency || computed.operational.urgency} />
            </ChartCard>
            <ChartCard title="Suportes por Prioridade" subtitle="Distribuição acumulada">
              <div className="relative h-full">
                <PriorityDonutChart data={realOperationalData?.priority || computed.operational.priority} />
                <div className="pointer-events-none absolute inset-0 flex flex-col items-center justify-center text-center">
                  <p className="text-xs font-semibold uppercase tracking-[0.3em] text-slate-400">
                    Total
                  </p>
                  <p className="text-3xl font-semibold text-slate-900">
                    {formatLargeNumber(
                      (realOperationalData?.priority || computed.operational.priority).reduce((sum, item) => sum + item.value, 0),
                    )}
                  </p>
                  <p className="text-xs uppercase tracking-[0.3em] text-slate-400">tickets</p>
                </div>
              </div>
            </ChartCard>
            <ChartCard title="Tendência de Tickets Criados" subtitle="Frequência temporal">
              <TrendLineChart data={computed.operational.trend} dataKey="tickets" />
            </ChartCard>
            <ChartCard title="SLA por Grupo" subtitle="Meta 90%">
              <SlaByGroupChart data={realOperationalData?.sla || computed.operational.sla} />
            </ChartCard>
            <ChartCard title="Volume por Grupo" subtitle="Tickets atribuídos">
              <VolumeByGroupChart data={realOperationalData?.volume || computed.operational.volume} />
            </ChartCard>
          </div>
        </section>
        )}

        {showEquipe && (
        <section className="mt-12 space-y-6">
          <div className="flex flex-wrap items-center justify-between gap-4">
            <div>
              <p className="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400">
                Performance dos Analistas
              </p>
              <h2 className="mt-2 text-3xl font-semibold text-slate-900">
                Placar de líderes e detalhes por analista
              </h2>
            </div>
            <span className="inline-flex items-center gap-2 rounded-full bg-white px-4 py-2 text-sm text-slate-500 shadow-inner">
              <Info className="h-4 w-4 text-slate-400" />
              Regras iguais ao documento oficial
            </span>
          </div>
          <div className="grid gap-6 lg:grid-cols-3">
            {computed.operational.leaderboard.map((leader, index) => (
              <motion.div
                key={leader.name}
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 0.1 * index }}
                className="rounded-3xl border border-slate-100 bg-white p-6 shadow-sm"
              >
                <p className="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400">
                  {index + 1}º Lugar
                </p>
                <p className="mt-2 text-2xl font-semibold text-slate-900">{leader.name}</p>
                <div className="mt-4 flex items-center gap-4 text-sm text-slate-500">
                  <div>
                    <p className="text-xs uppercase tracking-[0.3em] text-slate-400">Tickets</p>
                    <p className="text-xl font-semibold text-slate-900">
                      {leader.resolved.toLocaleString("pt-BR")}
                    </p>
                  </div>
                  <div>
                    <p className="text-xs uppercase tracking-[0.3em] text-slate-400">SLA</p>
                    <p className="text-xl font-semibold text-emerald-600">
                      {leader.sla.toFixed(0)}%
                    </p>
                  </div>
                  <div>
                    <p className="text-xs uppercase tracking-[0.3em] text-slate-400">TMA</p>
                    <p className="text-xl font-semibold text-slate-900">{leader.avgTime}</p>
                  </div>
                </div>
              </motion.div>
            ))}
          </div>
          <div className="grid gap-6 lg:grid-cols-2">
            <ChartCard title="Top 5 Analistas por Tickets Resolvidos" subtitle="Rolling 90 days">
              <TopAnalystsChart data={computed.operational.topAnalysts} />
            </ChartCard>
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5 }}
              className="rounded-3xl border border-slate-100 bg-white p-6 shadow-sm"
            >
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-xs font-semibold uppercase tracking-[0.35em] text-slate-400">
                    Detalhes por Analista
                  </p>
                  <h3 className="mt-2 text-xl font-semibold text-slate-900">
                    SLAs e reaberturas
                  </h3>
                </div>
                <button className="text-sm font-semibold text-slate-500 underline-offset-4 hover:underline">
                  Exportar CSV
                </button>
              </div>
              <div className="mt-4 overflow-x-auto">
                <table className="min-w-full divide-y divide-slate-100 text-sm">
                  <thead className="text-left text-xs uppercase tracking-[0.2em] text-slate-400">
                    <tr>
                      <th className="py-2 pr-4">Analista</th>
                      <th className="py-2 pr-4">Resolvidos</th>
                      <th className="py-2 pr-4">SLA</th>
                      <th className="py-2">Reaberturas</th>
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-slate-100">
                    {computed.operational.analystsTable.map(analyst => (
                      <tr key={analyst.name}>
                        <td className="py-3 pr-4 font-medium text-slate-900">{analyst.name}</td>
                        <td className="py-3 pr-4 text-slate-600">
                          {analyst.resolved.toLocaleString("pt-BR")}
                        </td>
                        <td className="py-3 pr-4 text-emerald-600">{analyst.sla}%</td>
                        <td className="py-3 text-slate-600">{analyst.reopened}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </motion.div>
          </div>
        </section>
        )}


      </div>
      )}
    </div>
        )}
  );
}


